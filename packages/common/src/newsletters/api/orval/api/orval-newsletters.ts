/* tslint:disable:interface-over-type-literal */
import { Awaited } from "../awaited-type";

/**
 * Generated by orval v6.31.0 üç∫
 * Do not edit manually.
 * Hub Newsletters Service
 * OpenAPI spec version: 0.0.1
 */
import { customClient } from "../custom-client";
export type GetSubscriptionsParams = {
  /**
   * Optional array of matching notification spec names to filter by
   */
  names?: string[];
  /**
   * Optional cadence to filter by
   */
  cadence?: Cadence;
  /**
   * Optional user id to filter by. Note this gets extracted/overridden from AGO token if provided
   */
  userId?: string;
  /**
   * Optional flag for filtering active subscriptions
   */
  active?: boolean;
  /**
   * The AGO id of the entity associated with the subscription
   */
  entityId?: string;
};

export interface IUpdateNotificationSpec {
  /** Description of the notification spec */
  description?: string;
  /** Name identifier for the notification spec */
  name?: string;
}

export interface ICreateNotificationSpec {
  /** Description of the notification spec */
  description?: string;
  /** Name identifier for the notification spec */
  name: string;
}

export interface IUpdateUser {
  /** Flag for deleted user */
  deleted?: boolean;
  /** Email for the subscriber. Will always be extracted from the token unless service token is used. */
  email?: string;
  /** First name for the subscriber. Will always be extracted from the token unless service token is used. */
  firstName?: string;
  /** Last name for the subscriber. Will always be extracted from the token unless service token is used. */
  lastName?: string;
  /** Flag for unsubscribed user */
  optedOut?: boolean;
  /** Username for the subscriber. Will always be extracted from the token unless service token is used. */
  username?: string;
}

export interface ICreateUser {
  /** ArcGIS Online id for a user. Will always be extracted from the token unless service token is used. */
  agoId?: string;
  /** Flag for deleted user */
  deleted?: boolean;
  /** Email for the subscriber. Will always be extracted from the token unless service token is used. */
  email?: string;
  /** First name for the subscriber. Will always be extracted from the token unless service token is used. */
  firstName?: string;
  /** Last name for the subscriber. Will always be extracted from the token unless service token is used. */
  lastName?: string;
  /** Flag for unsubscribed user */
  optedOut?: boolean;
  /** Username for the subscriber. Will always be extracted from the token unless service token is used. */
  username?: string;
}

/**
 * catalog for a subscription
 * @nullable
 */
export type IUpdateSubscriptionCatalog = { [key: string]: unknown } | null;

/**
 * Metadata for the subscription
 */
export type ISubscribeMetadata =
  | ICreateEventMetadata
  | ICreateTelemetryReportMetadata
  | ICreateDiscussionsOnEntityMetadata;

/**
 * catalog for a subscription
 * @nullable
 */
export type ISubscribeCatalog = { [key: string]: unknown } | null;

export type ISubscriptionMetadata = { [key: string]: unknown };

/**
 * @nullable
 */
export type ISubscriptionCatalog = { [key: string]: unknown } | null;

export interface IUser {
  agoId: string;
  createdAt: string;
  deleted: boolean;
  email: string;
  firstName: string;
  lastName: string;
  optedOut: boolean;
  updatedAt: string;
  username: string;
}

export interface INotificationSpec {
  createdAt: string;
  createdById: string;
  description: string;
  id: number;
  name: string;
  updatedAt: string;
}

/**
 * Metadata for the subscription
 */
export type ICreateSubscriptionMetadata =
  | ICreateEventMetadata
  | ICreateTelemetryReportMetadata
  | ICreateDiscussionsOnEntityMetadata;

/**
 * catalog for a subscription
 * @nullable
 */
export type ICreateSubscriptionCatalog = { [key: string]: unknown } | null;

export enum SubscriptionEntityType {
  DISCUSSION = "DISCUSSION",
}
export enum DeliveryMethod {
  EMAIL = "EMAIL",
}
export enum Cadence {
  ON_EVENT = "ON_EVENT",
  DAILY = "DAILY",
  WEEKLY = "WEEKLY",
  MONTHLY = "MONTHLY",
}
export enum SubscriptionAction {
  DISCUSSION_POST_PENDING = "DISCUSSION_POST_PENDING",
}
export interface IUpdateSubscription {
  /** Type of action representing user selections that further customize the subscription behavior */
  action?: SubscriptionAction;
  /** Flag to opt user in or out of subscription */
  active?: boolean;
  /** Frequency of the subscription */
  cadence?: Cadence;
  /**
   * catalog for a subscription
   * @nullable
   */
  catalog?: IUpdateSubscriptionCatalog;
  /** Delivery method for subscription, ie email or text */
  deliveryMethod?: DeliveryMethod;
  /** The AGO id of the entity associated with the subscription */
  entityId?: string;
  /** The type of entity associated with the subscription entityId */
  entityType?: SubscriptionEntityType;
  /** Last delivered datetime string of the subscription in ISO 8601 format */
  lastDelivery?: string;
  /** ArcGIS Online id for a user. Will always be extracted from the token unless service token is used. */
  userId?: string;
}

export interface ISubscribe {
  /** Type of action representing user selections that further customize the subscription behavior */
  action?: SubscriptionAction;
  /** ArcGIS Online id for a user. Will always be extracted from the token unless service token is used. */
  agoId?: string;
  /** Frequency of the subscription */
  cadence: Cadence;
  /**
   * catalog for a subscription
   * @nullable
   */
  catalog?: ISubscribeCatalog;
  /** Flag for deleted user */
  deleted?: boolean;
  /** Delivery method for subscription, ie email or text */
  deliveryMethod: DeliveryMethod;
  /** Email for the subscriber. Will always be extracted from the token unless service token is used. */
  email?: string;
  /** The AGO id of the entity associated with the subscription */
  entityId?: string;
  /** The type of entity associated with the subscription entityId */
  entityType?: SubscriptionEntityType;
  /** First name for the subscriber. Will always be extracted from the token unless service token is used. */
  firstName?: string;
  /** Last name for the subscriber. Will always be extracted from the token unless service token is used. */
  lastName?: string;
  /** Metadata for the subscription */
  metadata: ISubscribeMetadata;
  /** Notification spec name for the subscription */
  notificationSpecName: SystemNotificationSpecNames;
  /** Flag for unsubscribed user */
  optedOut?: boolean;
  /** Username for the subscriber. Will always be extracted from the token unless service token is used. */
  username?: string;
}

export interface ISubscription {
  action: SubscriptionAction;
  active: boolean;
  cadence: Cadence;
  /** @nullable */
  catalog?: ISubscriptionCatalog;
  createdAt: string;
  deliveryMethod: DeliveryMethod;
  entityId: string;
  entityType: SubscriptionEntityType;
  id: number;
  lastDelivery: string;
  metadata: ISubscriptionMetadata;
  notificationSpec?: INotificationSpec;
  notificationSpecId: number;
  updatedAt: string;
  user?: IUser;
  userId: string;
}

export enum SystemNotificationSpecNames {
  TELEMETRY_REPORT = "TELEMETRY_REPORT",
  EVENT = "EVENT",
  DISCUSSION_ON_ENTITY = "DISCUSSION_ON_ENTITY",
}
export interface ICreateSubscription {
  /** Type of action representing user selections that further customize the subscription behavior */
  action?: SubscriptionAction;
  /** Frequency of the subscription */
  cadence: Cadence;
  /**
   * catalog for a subscription
   * @nullable
   */
  catalog?: ICreateSubscriptionCatalog;
  /** Delivery method for subscription, ie email or text */
  deliveryMethod: DeliveryMethod;
  /** The AGO id of the entity associated with the subscription */
  entityId?: string;
  /** The type of entity associated with the subscription entityId */
  entityType?: SubscriptionEntityType;
  /** Metadata for the subscription */
  metadata: ICreateSubscriptionMetadata;
  /** Notification spec name for the subscription */
  notificationSpecName: SystemNotificationSpecNames;
  /** AGO id for user which subscription belongs to */
  userId: string;
}

export interface ICreateDiscussionsOnEntityMetadata {
  /** Entity name of the discussion */
  entityName?: string;
  /** Org short prefix for users org derived from token and AGO lookup */
  orgShortPrefix?: string;
  /** Notification spec name for the subscription */
  type: SystemNotificationSpecNames;
}

export interface ICreateEventMetadata {
  /** Event id for the subscription */
  eventId: string;
  /** Notification spec name for the subscription */
  type: SystemNotificationSpecNames;
}

export interface ICreateTelemetryReportMetadata {
  /** Hostname for telemetry report. */
  hostname: string;
  /** Notification spec name for the subscription */
  type: SystemNotificationSpecNames;
}

type SecondParameter<T extends (...args: any) => any> = Parameters<T>[1];

/**
 * Create a new newsletter subscription for an existing user id.
 */
export const createSubscription = (
  iCreateSubscription: ICreateSubscription,
  options?: SecondParameter<typeof customClient>
) => {
  return customClient<ISubscription>(
    {
      url: `/api/newsletters/v1/subscriptions`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: iCreateSubscription,
    },
    options
  );
};

/**
 * Get all newsletter subscriptions for a user.
 */
export const getSubscriptions = (
  params?: GetSubscriptionsParams,
  options?: SecondParameter<typeof customClient>
) => {
  return customClient<ISubscription[]>(
    { url: `/api/newsletters/v1/subscriptions`, method: "GET", params },
    options
  );
};

/**
 * Create a new newsletter subscription and a newsletter user if they do not exist (upsert, based on token).
 */
export const subscribe = (
  iSubscribe: ISubscribe,
  options?: SecondParameter<typeof customClient>
) => {
  return customClient<ISubscription>(
    {
      url: `/api/newsletters/v1/subscriptions/subscribe`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: iSubscribe,
    },
    options
  );
};

/**
 * Get a single newsletter subscription.
 */
export const getSubscription = (
  id: number,
  options?: SecondParameter<typeof customClient>
) => {
  return customClient<ISubscription>(
    { url: `/api/newsletters/v1/subscriptions/${id}`, method: "GET" },
    options
  );
};

/**
 * Update a newsletter subscription.
 */
export const updateSubscription = (
  id: number,
  iUpdateSubscription: IUpdateSubscription,
  options?: SecondParameter<typeof customClient>
) => {
  return customClient<ISubscription>(
    {
      url: `/api/newsletters/v1/subscriptions/${id}`,
      method: "PATCH",
      headers: { "Content-Type": "application/json" },
      data: iUpdateSubscription,
    },
    options
  );
};

/**
 * Delete a newsletter subscription.
 */
export const deleteSubscription = (
  id: number,
  options?: SecondParameter<typeof customClient>
) => {
  return customClient<ISubscription>(
    { url: `/api/newsletters/v1/subscriptions/${id}`, method: "DELETE" },
    options
  );
};

/**
 * Create a new newsletters user.
 */
export const createUser = (
  iCreateUser: ICreateUser,
  options?: SecondParameter<typeof customClient>
) => {
  return customClient<IUser>(
    {
      url: `/api/newsletters/v1/users`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: iCreateUser,
    },
    options
  );
};

/**
 * Get all newsletters users.
 */
export const getUsers = (options?: SecondParameter<typeof customClient>) => {
  return customClient<IUser[]>(
    { url: `/api/newsletters/v1/users`, method: "GET" },
    options
  );
};

/**
 * Get a single newsletters user by id.
 */
export const getUser = (
  userId: string,
  options?: SecondParameter<typeof customClient>
) => {
  return customClient<IUser>(
    { url: `/api/newsletters/v1/users/${userId}`, method: "GET" },
    options
  );
};

/**
 * Update a newsletters user by id.
 */
export const updateUser = (
  userId: string,
  iUpdateUser: IUpdateUser,
  options?: SecondParameter<typeof customClient>
) => {
  return customClient<IUser>(
    {
      url: `/api/newsletters/v1/users/${userId}`,
      method: "PATCH",
      headers: { "Content-Type": "application/json" },
      data: iUpdateUser,
    },
    options
  );
};

/**
 * Delete a newsletters user.
 */
export const deleteUser = (
  userId: string,
  options?: SecondParameter<typeof customClient>
) => {
  return customClient<IUser>(
    { url: `/api/newsletters/v1/users/${userId}`, method: "DELETE" },
    options
  );
};

/**
 * Create a new notification spec (subscription blueprint).
 */
export const createNotificationSpec = (
  iCreateNotificationSpec: ICreateNotificationSpec,
  options?: SecondParameter<typeof customClient>
) => {
  return customClient<INotificationSpec>(
    {
      url: `/api/newsletters/v1/notification-specs`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: iCreateNotificationSpec,
    },
    options
  );
};

/**
 * Get all notification specs.
 */
export const getNotificationSpecs = (
  options?: SecondParameter<typeof customClient>
) => {
  return customClient<INotificationSpec[]>(
    { url: `/api/newsletters/v1/notification-specs`, method: "GET" },
    options
  );
};

/**
 * Get a single notification spec by id.
 */
export const getNotificationSpec = (
  id: number,
  options?: SecondParameter<typeof customClient>
) => {
  return customClient<INotificationSpec>(
    { url: `/api/newsletters/v1/notification-specs/${id}`, method: "GET" },
    options
  );
};

/**
 * Update a notification spec by id.
 */
export const updateNotificationSpec = (
  id: number,
  iUpdateNotificationSpec: IUpdateNotificationSpec,
  options?: SecondParameter<typeof customClient>
) => {
  return customClient<INotificationSpec>(
    {
      url: `/api/newsletters/v1/notification-specs/${id}`,
      method: "PATCH",
      headers: { "Content-Type": "application/json" },
      data: iUpdateNotificationSpec,
    },
    options
  );
};

/**
 * Delete a notification spec by id.
 */
export const deleteNotificationSpec = (
  id: number,
  options?: SecondParameter<typeof customClient>
) => {
  return customClient<INotificationSpec>(
    { url: `/api/newsletters/v1/notification-specs/${id}`, method: "DELETE" },
    options
  );
};

export type CreateSubscriptionResult = NonNullable<
  Awaited<ReturnType<typeof createSubscription>>
>;
export type GetSubscriptionsResult = NonNullable<
  Awaited<ReturnType<typeof getSubscriptions>>
>;
export type SubscribeResult = NonNullable<
  Awaited<ReturnType<typeof subscribe>>
>;
export type GetSubscriptionResult = NonNullable<
  Awaited<ReturnType<typeof getSubscription>>
>;
export type UpdateSubscriptionResult = NonNullable<
  Awaited<ReturnType<typeof updateSubscription>>
>;
export type DeleteSubscriptionResult = NonNullable<
  Awaited<ReturnType<typeof deleteSubscription>>
>;
export type CreateUserResult = NonNullable<
  Awaited<ReturnType<typeof createUser>>
>;
export type GetUsersResult = NonNullable<Awaited<ReturnType<typeof getUsers>>>;
export type GetUserResult = NonNullable<Awaited<ReturnType<typeof getUser>>>;
export type UpdateUserResult = NonNullable<
  Awaited<ReturnType<typeof updateUser>>
>;
export type DeleteUserResult = NonNullable<
  Awaited<ReturnType<typeof deleteUser>>
>;
export type CreateNotificationSpecResult = NonNullable<
  Awaited<ReturnType<typeof createNotificationSpec>>
>;
export type GetNotificationSpecsResult = NonNullable<
  Awaited<ReturnType<typeof getNotificationSpecs>>
>;
export type GetNotificationSpecResult = NonNullable<
  Awaited<ReturnType<typeof getNotificationSpec>>
>;
export type UpdateNotificationSpecResult = NonNullable<
  Awaited<ReturnType<typeof updateNotificationSpec>>
>;
export type DeleteNotificationSpecResult = NonNullable<
  Awaited<ReturnType<typeof deleteNotificationSpec>>
>;
