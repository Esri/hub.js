/* tslint:disable:interface-over-type-literal */
import { Awaited } from "../awaited-type";

/**
 * Generated by orval v6.24.0 üç∫
 * Do not edit manually.
 * Hub Newsletters Service
 * OpenAPI spec version: 0.0.1
 */
import { customClient } from "../custom-client";
export type GetSubscriptionsParams = {
  /**
   * Optional array of matching notification spec names to filter by
   */
  names?: string[];
  /**
   * Optional cadence to filter by
   */
  cadence?: Cadence;
  /**
   * Optional user id to filter by. Note this gets extracted/overridden from AGO token if provided
   */
  userId?: string;
  /**
   * Optional flag for filtering active subscriptions
   */
  active?: boolean;
};

export interface IUpdateNotificationSpec {
  /** Description of the notification spec */
  description?: string;
  /** Name identifier for the notification spec */
  name?: string;
}

export interface ICreateNotificationSpec {
  /** Description of the notification spec */
  description?: string;
  /** Name identifier for the notification spec */
  name: string;
}

export interface IUpdateUser {
  /** Flag for deleted user */
  deleted?: boolean;
  /** Email for the subscriber. Will always be extracted from the token unless service token is used. */
  email?: string;
  /** First name for the subscriber. Will always be extracted from the token unless service token is used. */
  firstName?: string;
  /** Last name for the subscriber. Will always be extracted from the token unless service token is used. */
  lastName?: string;
  /** Flag for unsubscribed user */
  optedOut?: boolean;
  /** Username for the subscriber. Will always be extracted from the token unless service token is used. */
  username?: string;
}

export interface ICreateUser {
  /** ArcGIS Online id for a user. Will always be extracted from the token unless service token is used. */
  agoId?: string;
  /** Flag for deleted user */
  deleted?: boolean;
  /** Email for the subscriber. Will always be extracted from the token unless service token is used. */
  email?: string;
  /** First name for the subscriber. Will always be extracted from the token unless service token is used. */
  firstName?: string;
  /** Last name for the subscriber. Will always be extracted from the token unless service token is used. */
  lastName?: string;
  /** Flag for unsubscribed user */
  optedOut?: boolean;
  /** Username for the subscriber. Will always be extracted from the token unless service token is used. */
  username?: string;
}

/**
 * catalog for a subscription
 */
export type IUpdateSubscriptionCatalog = ICreateCatalog | null;

export interface IUpdateSubscription {
  /** An array of actions representing user selections that further customize the subscription behavior */
  actions?: SubscriptionActions[];
  /** Flag to opt user in or out of subscription */
  active?: boolean;
  /** Frequency of the subscription */
  cadence?: Cadence;
  /** catalog for a subscription */
  catalog?: IUpdateSubscriptionCatalog;
  /** Delivery method for subscription, ie email or text */
  deliveryMethod?: DeliveryMethod;
  /** The AGO id of the entity associated with the subscription */
  entityId?: string;
  /** The type of entity associated with the subscription entityId */
  entityType?: SubscriptionEntityType;
  /** Last delivered datetime string of the subscription in ISO 8601 format */
  lastDelivery?: string;
  /** ArcGIS Online id for a user. Will always be extracted from the token unless service token is used. */
  userId?: string;
}

/**
 * Metadata for the subscription
 */
export type ISubscribeMetadata =
  | ICreateEventMetadata
  | ICreateTelemetryReportMetadata;

/**
 * catalog for a subscription
 */
export type ISubscribeCatalog = ICreateCatalog | null;

export interface ISubscribe {
  /** An array of actions representing user selections that further customize the subscription behavior */
  actions?: SubscriptionActions[];
  /** ArcGIS Online id for a user. Will always be extracted from the token unless service token is used. */
  agoId?: string;
  /** Frequency of the subscription */
  cadence: Cadence;
  /** catalog for a subscription */
  catalog?: ISubscribeCatalog;
  /** Flag for deleted user */
  deleted?: boolean;
  /** Delivery method for subscription, ie email or text */
  deliveryMethod: DeliveryMethod;
  /** Email for the subscriber. Will always be extracted from the token unless service token is used. */
  email?: string;
  /** The AGO id of the entity associated with the subscription */
  entityId?: string;
  /** The type of entity associated with the subscription entityId */
  entityType?: SubscriptionEntityType;
  /** First name for the subscriber. Will always be extracted from the token unless service token is used. */
  firstName?: string;
  /** Last name for the subscriber. Will always be extracted from the token unless service token is used. */
  lastName?: string;
  /** Metadata for the subscription */
  metadata: ISubscribeMetadata;
  /** Notification spec name for the subscription */
  notificationSpecName: SystemNotificationSpecNames;
  /** Flag for unsubscribed user */
  optedOut?: boolean;
  /** Username for the subscriber. Will always be extracted from the token unless service token is used. */
  username?: string;
}

export type ISubscriptionMetadata = { [key: string]: any };

export type ISubscriptionCatalog = { [key: string]: any } | null;

export interface IUser {
  agoId: string;
  createdAt: string;
  deleted: boolean;
  email: string;
  firstName: string;
  lastName: string;
  optedOut: boolean;
  updatedAt: string;
  username: string;
}

export interface INotificationSpec {
  createdAt: string;
  createdById: string;
  description: string;
  id: number;
  name: string;
  updatedAt: string;
}

/**
 * Metadata for the subscription
 */
export type ICreateSubscriptionMetadata =
  | ICreateEventMetadata
  | ICreateTelemetryReportMetadata;

/**
 * catalog for a subscription
 */
export type ICreateSubscriptionCatalog = ICreateCatalog | null;

export enum SubscriptionEntityType {
  DISCUSSION = "DISCUSSION",
}
export enum DeliveryMethod {
  EMAIL = "EMAIL",
}
export enum Cadence {
  ON_EVENT = "ON_EVENT",
  DAILY = "DAILY",
  WEEKLY = "WEEKLY",
  MONTHLY = "MONTHLY",
}
export interface ISubscription {
  actions: SubscriptionActions[];
  active: boolean;
  cadence: Cadence;
  catalog?: ISubscriptionCatalog;
  createdAt: string;
  deliveryMethod: DeliveryMethod;
  entityId: string;
  entityType: SubscriptionEntityType;
  id: number;
  lastDelivery: string;
  metadata: ISubscriptionMetadata;
  notificationSpec?: INotificationSpec;
  notificationSpecId: number;
  updatedAt: string;
  user?: IUser;
  userId: string;
}

export enum SystemNotificationSpecNames {
  TELEMETRY_REPORT = "TELEMETRY_REPORT",
  EVENT = "EVENT",
  DISCUSSION_ON_ENTITY = "DISCUSSION_ON_ENTITY",
}
export interface ICreateSubscription {
  /** An array of actions representing user selections that further customize the subscription behavior */
  actions?: SubscriptionActions[];
  /** Frequency of the subscription */
  cadence: Cadence;
  /** catalog for a subscription */
  catalog?: ICreateSubscriptionCatalog;
  /** Delivery method for subscription, ie email or text */
  deliveryMethod: DeliveryMethod;
  /** The AGO id of the entity associated with the subscription */
  entityId?: string;
  /** The type of entity associated with the subscription entityId */
  entityType?: SubscriptionEntityType;
  /** Metadata for the subscription */
  metadata: ICreateSubscriptionMetadata;
  /** Notification spec name for the subscription */
  notificationSpecName: SystemNotificationSpecNames;
  /** AGO id for user which subscription belongs to */
  userId: string;
}

export interface ICreateCatalogScope {
  [key: string]: any;
}

export interface ICreateCatalogIntegrity {
  /** Hash to verify the integrity of the catalog. Only verified when the catalog is loaded into the editor. If the hashes do not match, the catalog will not be loaded and the user will simply have the option to reset the catalog */
  collections: string;
  /** Hash to verify the integrity of the catalog. Only verified when the catalog is loaded into the editor. If the hashes do not match, the catalog will not be loaded and the user will simply have the option to reset the catalog */
  scopes: string;
}

export enum SortOrder {
  ASC = "ASC",
  DESC = "DESC",
}
export interface ICreateCatalogCollection {
  /** Specify the includes to be requested when working with this collection */
  include?: string[];
  /** Unique key, used for query params and telemetry */
  key: string;
  /** String to show in the UI. translated. */
  label: string;
  /** Default query for the Collection */
  scope: ICreateCatalogCollectionQuery;
  /** Default sort order for the Collection */
  sortDirection?: SortOrder;
  /** Default sort field for the Collection */
  sortField?: string;
  /** What entity is this query targeting. This is used internally to ensure we query the correct API */
  targetEntity: EntityType;
}

export interface ICreateCatalog {
  /** Collections within the catalog */
  collections?: ICreateCatalogCollection[];
  /** Optional emoji to show in the UI */
  emojii?: string;
  /** Hashes to verify the integrity of the catalog. Only verified when the catalog is loaded into the editor */
  integrity?: ICreateCatalogIntegrity;
  /** The schema version of the catalog */
  schemaVersion: number;
  /** Filter defines the "scopes" of the Catalog, on a per entity type basis */
  scopes?: ICreateCatalogScope;
  /** Title for the gallery */
  title?: string;
}

/**
 * Additional properties. Useful for groupMember queries where we need to send in the groupId to construct the url
 */
export type ICreateCatalogCollectionQueryProperties = { [key: string]: any };

export interface ICreateCatalogCollectionQueryFilterPredicate {
  [key: string]: any;
}

export enum FilterOperation {
  AND = "AND",
  OR = "OR",
}
export interface ICreateCatalogCollectionQueryFilter {
  /** The operation to apply to query filter */
  operation?: FilterOperation;
  /** A predicate is a set of key/value pairs that can be evaluated into a boolean value in a search system. Properties can be `string`, `string[]`, `IMatchOption`, `IDateRange<number>` or  `IRelativeDate`. Some properties are booleans and other properties have a limited set of values that can be passed. The [Hub Search Guide](/hub.js/guides/hub-search) contains a list of properties that can be sent to the ArcGIS Portal API. */
  predicates: ICreateCatalogCollectionQueryFilterPredicate[];
}

export enum WellKnownCollection {
  content = "content",
  dataset = "dataset",
  document = "document",
  event = "event",
  feedback = "feedback",
  initiative = "initiative",
  people = "people",
  site = "site",
  team = "team",
  template = "template",
  project = "project",
  channel = "channel",
  discussion = "discussion",
  eventAttendee = "eventAttendee",
}
export enum EntityType {
  item = "item",
  group = "group",
  user = "user",
  portalUser = "portalUser",
  communityUser = "communityUser",
  groupMember = "groupMember",
  event = "event",
  channel = "channel",
  discussionPost = "discussionPost",
  eventAttendee = "eventAttendee",
}
export interface ICreateCatalogCollectionQuery {
  /** This is used to determine what IHubCollection definition JSON object can be created. We use HubFamily here to define most of the collections to ensure consistency */
  collection?: WellKnownCollection;
  /** Filters for the query */
  filters: ICreateCatalogCollectionQueryFilter[];
  /** Additional properties. Useful for groupMember queries where we need to send in the groupId to construct the url */
  properties?: ICreateCatalogCollectionQueryProperties;
  /** What entity is this query targeting. This is used internally to ensure we query the correct API */
  targetEntity: EntityType;
}

export enum SubscriptionActions {
  DISCUSSION_POST_PENDING = "DISCUSSION_POST_PENDING",
}
export interface ICreateEventMetadata {
  /** Event id for the subscription */
  eventId: string;
}

export interface ICreateTelemetryReportMetadata {
  /** Hostname for telemetry report. */
  hostname: string;
}

type SecondParameter<T extends (...args: any) => any> = Parameters<T>[1];

export const createSubscription = (
  iCreateSubscription: ICreateSubscription,
  options?: SecondParameter<typeof customClient>
) => {
  return customClient<ISubscription>(
    {
      url: `/api/newsletters/v1/subscriptions`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: iCreateSubscription,
    },
    options
  );
};

export const getSubscriptions = (
  params?: GetSubscriptionsParams,
  options?: SecondParameter<typeof customClient>
) => {
  return customClient<ISubscription[]>(
    { url: `/api/newsletters/v1/subscriptions`, method: "GET", params },
    options
  );
};

export const subscribe = (
  iSubscribe: ISubscribe,
  options?: SecondParameter<typeof customClient>
) => {
  return customClient<ISubscription>(
    {
      url: `/api/newsletters/v1/subscriptions/subscribe`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: iSubscribe,
    },
    options
  );
};

export const getSubscription = (
  id: number,
  options?: SecondParameter<typeof customClient>
) => {
  return customClient<ISubscription>(
    { url: `/api/newsletters/v1/subscriptions/${id}`, method: "GET" },
    options
  );
};

export const updateSubscription = (
  id: number,
  iUpdateSubscription: IUpdateSubscription,
  options?: SecondParameter<typeof customClient>
) => {
  return customClient<ISubscription>(
    {
      url: `/api/newsletters/v1/subscriptions/${id}`,
      method: "PATCH",
      headers: { "Content-Type": "application/json" },
      data: iUpdateSubscription,
    },
    options
  );
};

export const deleteSubscription = (
  id: number,
  options?: SecondParameter<typeof customClient>
) => {
  return customClient<ISubscription>(
    { url: `/api/newsletters/v1/subscriptions/${id}`, method: "DELETE" },
    options
  );
};

export const createUser = (
  iCreateUser: ICreateUser,
  options?: SecondParameter<typeof customClient>
) => {
  return customClient<IUser>(
    {
      url: `/api/newsletters/v1/users`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: iCreateUser,
    },
    options
  );
};

export const getUsers = (options?: SecondParameter<typeof customClient>) => {
  return customClient<IUser[]>(
    { url: `/api/newsletters/v1/users`, method: "GET" },
    options
  );
};

export const getUser = (
  userId: string,
  options?: SecondParameter<typeof customClient>
) => {
  return customClient<IUser>(
    { url: `/api/newsletters/v1/users/${userId}`, method: "GET" },
    options
  );
};

export const updateUser = (
  userId: string,
  iUpdateUser: IUpdateUser,
  options?: SecondParameter<typeof customClient>
) => {
  return customClient<IUser>(
    {
      url: `/api/newsletters/v1/users/${userId}`,
      method: "PATCH",
      headers: { "Content-Type": "application/json" },
      data: iUpdateUser,
    },
    options
  );
};

export const deleteUser = (
  userId: string,
  options?: SecondParameter<typeof customClient>
) => {
  return customClient<IUser>(
    { url: `/api/newsletters/v1/users/${userId}`, method: "DELETE" },
    options
  );
};

export const createNotificationSpec = (
  iCreateNotificationSpec: ICreateNotificationSpec,
  options?: SecondParameter<typeof customClient>
) => {
  return customClient<INotificationSpec>(
    {
      url: `/api/newsletters/v1/notification-specs`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: iCreateNotificationSpec,
    },
    options
  );
};

export const getNotificationSpecs = (
  options?: SecondParameter<typeof customClient>
) => {
  return customClient<INotificationSpec[]>(
    { url: `/api/newsletters/v1/notification-specs`, method: "GET" },
    options
  );
};

export const getNotificationSpec = (
  id: number,
  options?: SecondParameter<typeof customClient>
) => {
  return customClient<INotificationSpec>(
    { url: `/api/newsletters/v1/notification-specs/${id}`, method: "GET" },
    options
  );
};

export const updateNotificationSpec = (
  id: number,
  iUpdateNotificationSpec: IUpdateNotificationSpec,
  options?: SecondParameter<typeof customClient>
) => {
  return customClient<INotificationSpec>(
    {
      url: `/api/newsletters/v1/notification-specs/${id}`,
      method: "PATCH",
      headers: { "Content-Type": "application/json" },
      data: iUpdateNotificationSpec,
    },
    options
  );
};

export const deleteNotificationSpec = (
  id: number,
  options?: SecondParameter<typeof customClient>
) => {
  return customClient<INotificationSpec>(
    { url: `/api/newsletters/v1/notification-specs/${id}`, method: "DELETE" },
    options
  );
};

export type CreateSubscriptionResult = NonNullable<
  Awaited<ReturnType<typeof createSubscription>>
>;
export type GetSubscriptionsResult = NonNullable<
  Awaited<ReturnType<typeof getSubscriptions>>
>;
export type SubscribeResult = NonNullable<
  Awaited<ReturnType<typeof subscribe>>
>;
export type GetSubscriptionResult = NonNullable<
  Awaited<ReturnType<typeof getSubscription>>
>;
export type UpdateSubscriptionResult = NonNullable<
  Awaited<ReturnType<typeof updateSubscription>>
>;
export type DeleteSubscriptionResult = NonNullable<
  Awaited<ReturnType<typeof deleteSubscription>>
>;
export type CreateUserResult = NonNullable<
  Awaited<ReturnType<typeof createUser>>
>;
export type GetUsersResult = NonNullable<Awaited<ReturnType<typeof getUsers>>>;
export type GetUserResult = NonNullable<Awaited<ReturnType<typeof getUser>>>;
export type UpdateUserResult = NonNullable<
  Awaited<ReturnType<typeof updateUser>>
>;
export type DeleteUserResult = NonNullable<
  Awaited<ReturnType<typeof deleteUser>>
>;
export type CreateNotificationSpecResult = NonNullable<
  Awaited<ReturnType<typeof createNotificationSpec>>
>;
export type GetNotificationSpecsResult = NonNullable<
  Awaited<ReturnType<typeof getNotificationSpecs>>
>;
export type GetNotificationSpecResult = NonNullable<
  Awaited<ReturnType<typeof getNotificationSpec>>
>;
export type UpdateNotificationSpecResult = NonNullable<
  Awaited<ReturnType<typeof updateNotificationSpec>>
>;
export type DeleteNotificationSpecResult = NonNullable<
  Awaited<ReturnType<typeof deleteNotificationSpec>>
>;
