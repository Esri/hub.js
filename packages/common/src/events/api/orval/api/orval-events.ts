/* tslint:disable:interface-over-type-literal */
/**
 * Generated by orval v6.24.0 üç∫
 * Do not edit manually.
 * Hub Events Service
 * OpenAPI spec version: 0.0.1
 */
import { Awaited } from "../awaited-type";
import { customClient } from "../custom-client";
export interface IUpdateRegistration {
  /** Role of the user in the event */
  role?: RegistrationRole;
  /** Status of the registration */
  status?: RegistrationStatus;
  /** Attendance type for this registration */
  type?: EventAttendanceType;
}

export interface IPagedRegistrationResponse {
  items: IRegistration[];
  nextStart: number;
  total: number;
}

export enum RegistrationSort {
  createdAt = "createdAt",
  updatedAt = "updatedAt",
  firstName = "firstName",
  lastName = "lastName",
  username = "username",
}
export type GetRegistrationsParams = {
  /**
   * Event id being registered for
   */
  eventId?: string;
  /**
   * ArcGIS Online id for a user
   */
  userId?: string;
  /**
   * comma separated string list of registration roles
   */
  role?: string;
  /**
   * comma separated string list of registration statuses
   */
  status?: string;
  /**
   * comma separated string list of registration types
   */
  type?: string;
  /**
   * latest ISO8601 updatedAt for the registrations
   */
  updatedAtBefore?: string;
  /**
   * earliest ISO8601 updatedAt for the registrations
   */
  updatedAtAfter?: string;
  /**
   * filter to be matched to firstName, lastName, or username
   */
  name?: string;
  /**
   * the max amount of registrations to return
   */
  num?: string;
  /**
   * the index to start at
   */
  start?: string;
  /**
   * property to sort results by
   */
  sortBy?: RegistrationSort;
  /**
   * sort order desc or asc
   */
  sortOrder?: EventSortOrder;
};

export interface ICreateRegistration {
  /** ArcGIS Online id for a user. Will always be extracted from the token unless service token is used. */
  agoId?: string;
  /** Email for the subscriber. Will always be extracted from the token unless service token is used. */
  email?: string;
  /** Event id being registered for */
  eventId: string;
  /** First name for the subscriber. Will always be extracted from the token unless service token is used. */
  firstName?: string;
  /** Last name for the subscriber. Will always be extracted from the token unless service token is used. */
  lastName?: string;
  /** Role of the user in the event */
  role?: RegistrationRole;
  /** Attendance type for this registration */
  type: EventAttendanceType;
  /** Username for the subscriber. Will always be extracted from the token unless service token is used. */
  username?: string;
}

/**
 * Online meeting for the event
 */
export type IUpdateEventOnlineMeeting = ICreateOnlineMeeting | null;

/**
 * Location for the event
 */
export type IUpdateEventLocation = ICreateEventLocation | null;

/**
 * capabilities for an event
 */
export type IUpdateEventCapabilities = { [key: string]: any } | null;

export interface IUpdateEvent {
  /** Access level of the event */
  access?: EventAccess;
  /** Flag for all day event */
  allDay?: boolean;
  /** Boolean to indicate if users can register for an event */
  allowRegistration?: boolean;
  /** Items associated with the event */
  associations?: ICreateEventAssociation[];
  /** Valid ways to attend the event */
  attendanceType?: EventAttendanceType[];
  /** capabilities for an event */
  capabilities?: IUpdateEventCapabilities;
  /** categories for the event */
  categories?: string[];
  /** Description of the event */
  description?: string;
  /** Groups with edit access to the event */
  editGroups?: string[];
  /** end date string formatted YYYY-MM-DD */
  endDate?: string;
  /** end time string 24 hour formatted HH:MM:SS */
  endTime?: string;
  /** in-person capacity for the event. Minimum value is 1 */
  inPersonCapacity?: number;
  /** Location for the event */
  location?: IUpdateEventLocation;
  /** Flag to notify attendees */
  notifyAttendees?: boolean;
  /** Online meeting for the event */
  onlineMeeting?: IUpdateEventOnlineMeeting;
  /** Groups with read access to the event */
  readGroups?: string[];
  /** start date string formatted YYYY-MM-DD */
  startDate?: string;
  /** start time string 24 hour formatted HH:MM:SS */
  startTime?: string;
  /** Status of the event */
  status?: EventStatus;
  /** Summary of the event */
  summary?: string;
  /** Tags for the event */
  tags?: string[];
  /** IANA time zone for the event */
  timeZone?: string;
  /** Title of the event */
  title?: string;
}

export interface IPagedEventResponse {
  items: IEvent[];
  nextStart: number;
  total: number;
}

export enum EventSortOrder {
  asc = "asc",
  desc = "desc",
}
export enum EventSort {
  title = "title",
  startDateTime = "startDateTime",
  createdAt = "createdAt",
  updatedAt = "updatedAt",
}
export type GetEventsParams = {
  /**
   * Comma separated string list of EventAccess. Example: PRIVATE,ORG,PUBLIC
   */
  access?: string;
  /**
   * Comma separated string list of AttendanceTypes. Example:  VIRTUAL,IN_PERSON
   */
  attendanceTypes?: string;
  /**
   * boolean to filter events that can be edited by the user
   */
  canEdit?: string;
  /**
   * Comma separated string list of categories
   */
  categories?: string;
  /**
   * Comma separated string list of createdByIds
   */
  createdByIds?: string;
  /**
   * Comma separated string list of edit groupIds
   */
  editGroups?: string;
  /**
   * Comma separated string list of associated entityIds
   */
  entityIds?: string;
  /**
   * Comma separated string list of associated entity types. Example: Hub Site Application,Hub Initiative,Hub Project
   */
  entityTypes?: string;
  /**
   * Comma separated string list of event ids
   */
  eventIds?: string;
  /**
   * Comma separated string list of relation fields to include in response. Example: associations,creator,location,onlineMeeting,registrations
   */
  include?: string;
  /**
   * the max amount of events to return
   */
  num?: string;
  /**
   * Comma separated string list of read groupIds
   */
  readGroups?: string;
  /**
   * Event property to sort results by
   */
  sortBy?: EventSort;
  /**
   * sort results order desc or asc
   */
  sortOrder?: EventSortOrder;
  /**
   * the index to start at
   */
  start?: string;
  /**
   * earliest ISO8601 start date-time for the events
   */
  startDateTimeAfter?: string;
  /**
   * latest ISO8601 start date-time for the events
   */
  startDateTimeBefore?: string;
  /**
   * comma separated string list of event statuses. Example: PRIVATE,ORG,PUBLIC
   */
  status?: string;
  /**
   * Comma separated string list of tags
   */
  tags?: string;
  /**
   * string to match within an event title
   */
  title?: string;
  /**
   * orgId string
   */
  orgId?: string;
};

export interface IRegistrationPermission {
  canDelete: boolean;
  canEdit: boolean;
}

export interface IRegistration {
  createdAt: string;
  createdBy?: IUser;
  createdById: string;
  event?: IEvent;
  eventId: string;
  id: string;
  permission: IRegistrationPermission;
  role: RegistrationRole;
  status: RegistrationStatus;
  type: EventAttendanceType;
  updatedAt: string;
  user?: IUser;
  userId: string;
}

export type IEventCapabilities = { [key: string]: any } | null;

export interface IEventPermission {
  canDelete: boolean;
  canEdit: boolean;
  canSetAccessToOrg: boolean;
  canSetAccessToPrivate: boolean;
  canSetAccessToPublic: boolean;
  canSetStatusToCancelled: boolean;
  canSetStatusToRemoved: boolean;
}

export interface IEventRegistrationCount {
  inPerson: number;
  virtual: number;
}

export enum RegistrationStatus {
  PENDING = "PENDING",
  ACCEPTED = "ACCEPTED",
  DECLINED = "DECLINED",
  BLOCKED = "BLOCKED",
}
export enum RegistrationRole {
  OWNER = "OWNER",
  ORGANIZER = "ORGANIZER",
  ATTENDEE = "ATTENDEE",
}
export enum EventStatus {
  PLANNED = "PLANNED",
  CANCELED = "CANCELED",
  REMOVED = "REMOVED",
}
export interface IOnlineMeeting {
  capacity: number | null;
  createdAt: string;
  details: string | null;
  eventId: string;
  updatedAt: string;
  url: string;
}

export type IEventLocationGeometriesItem = { [key: string]: any };

export interface ILocationSpatialReference {
  latestVcsWkid?: number;
  latestWkid?: number;
  latestWkt?: string;
  vcsWkid?: number;
  wkid?: number;
  wkt?: string;
}

export type IEventLocationSpatialReference = ILocationSpatialReference | null;

export interface IEventLocation {
  addNum: string | null;
  city: string | null;
  cntryName: string | null;
  eventId: string;
  extent: number[][] | null;
  geometries: IEventLocationGeometriesItem[] | null;
  id: string;
  nbrhd: string | null;
  placeAddr: string | null;
  placeName: string | null;
  postal: number | null;
  region: string | null;
  spatialReference: IEventLocationSpatialReference;
  stDir: string | null;
  stName: string | null;
  stType: string | null;
  subRegion: string | null;
  type: EventLocationType;
}

export interface IUser {
  agoId: string;
  createdAt: string;
  deleted: boolean;
  email: string;
  firstName: string;
  lastName: string;
  optedOut: boolean;
  updatedAt: string;
  username: string;
}

export interface IEventAssociation {
  entityId: string;
  entityType: EventAssociationEntityType;
  eventId: string;
}

export interface IEvent {
  access: EventAccess;
  allDay: boolean;
  allowRegistration: boolean;
  associations?: IEventAssociation[];
  attendanceType: EventAttendanceType[];
  capabilities?: IEventCapabilities;
  categories: string[];
  createdAt: string;
  createdById: string | null;
  creator?: IUser;
  description: string | null;
  editGroups: string[];
  endDate: string;
  endDateTime: string;
  endTime: string;
  id: string;
  inPersonCapacity: number | null;
  location?: IEventLocation;
  notifyAttendees: boolean;
  onlineMeeting?: IOnlineMeeting;
  orgId: string;
  permission: IEventPermission;
  readGroups: string[];
  recurrence: string | null;
  registrationCount?: IEventRegistrationCount;
  registrations?: IRegistration[];
  startDate: string;
  startDateTime: string;
  startTime: string;
  status: EventStatus;
  summary: string | null;
  tags: string[];
  timeZone: string;
  title: string;
  updatedAt: string;
}

/**
 * capabilities for an event
 */
export type ICreateEventCapabilities = { [key: string]: any } | null;

export interface ICreateOnlineMeeting {
  /** Capacity of the online meeting. Minimum value is 1 */
  capacity?: number;
  /** Details related to the online meeting */
  details?: string;
  /** Url for the online meeting */
  url: string;
}

export interface ICreateEvent {
  /** Access level of the event */
  access?: EventAccess;
  /** ArcGIS Online id for a user. Will always be extracted from the token unless service token is used. */
  agoId?: string;
  /** Flag for all day event */
  allDay?: boolean;
  /** Boolean to indicate if users can register for an event */
  allowRegistration?: boolean;
  /** Items associated with the event */
  associations?: ICreateEventAssociation[];
  /** Valid ways to attend the event */
  attendanceType?: EventAttendanceType[];
  /** capabilities for an event */
  capabilities?: ICreateEventCapabilities;
  /** categories for the event */
  categories?: string[];
  /** Description of the event */
  description?: string;
  /** Groups with edit access to the event */
  editGroups?: string[];
  /** Email for the subscriber. Will always be extracted from the token unless service token is used. */
  email?: string;
  /** end date string formatted YYYY-MM-DD */
  endDate: string;
  /** end time string 24 hour formatted HH:MM:SS */
  endTime: string;
  /** First name for the subscriber. Will always be extracted from the token unless service token is used. */
  firstName?: string;
  /** in-person capacity for the event. Minimum value is 1 */
  inPersonCapacity?: number;
  /** Last name for the subscriber. Will always be extracted from the token unless service token is used. */
  lastName?: string;
  /** Location for the event */
  location?: ICreateEventLocationProperty;
  /** Flag to notify attendees */
  notifyAttendees?: boolean;
  /** Online meeting for the event. Required if attendanceType includes VIRTUAL */
  onlineMeeting?: ICreateOnlineMeeting;
  /** Groups with read access to the event */
  readGroups?: string[];
  /** start date string formatted YYYY-MM-DD */
  startDate: string;
  /** start time string 24 hour formatted HH:MM:SS */
  startTime: string;
  /** Summary of the event */
  summary?: string;
  /** Tags for the event */
  tags?: string[];
  /** IANA time zone for the event */
  timeZone: string;
  /** Title of the event */
  title: string;
  /** Username for the subscriber. Will always be extracted from the token unless service token is used. */
  username?: string;
}

export type ICreateEventLocationGeometriesItem = { [key: string]: any };

export enum EventLocationType {
  none = "none",
  custom = "custom",
  org = "org",
  item = "item",
}
export interface ICreateLocationSpatialReference {
  latestVcsWkid?: number;
  latestWkid?: number;
  latestWkt?: string;
  vcsWkid?: number;
  wkid?: number;
  wkt?: string;
}

export interface ICreateEventLocation {
  /** Address number */
  addNum?: string;
  /** City */
  city?: string;
  /** Country name */
  cntryName?: string;
  /** 2D array of numbers */
  extent?: number[][];
  /** Array of esri geometry objects */
  geometries?: ICreateEventLocationGeometriesItem[];
  /** Neighborhood */
  nbrhd?: string;
  /** Place address */
  placeAddr?: string;
  /** Place name */
  placeName?: string;
  /** Postal */
  postal?: number;
  /** Region */
  region?: string;
  /** Spatial reference */
  spatialReference?: ICreateLocationSpatialReference;
  /** Street direction */
  stDir?: string;
  /** Street name */
  stName?: string;
  /** Street type */
  stType?: string;
  /** Sub region */
  subRegion?: string;
  /** Location type */
  type: EventLocationType;
}

/**
 * Location for the event
 */
export type ICreateEventLocationProperty = ICreateEventLocation | null;

export enum EventAttendanceType {
  VIRTUAL = "VIRTUAL",
  IN_PERSON = "IN_PERSON",
}
export enum EventAssociationEntityType {
  Hub_Site_Application = "Hub Site Application",
  Hub_Initiative = "Hub Initiative",
  Hub_Project = "Hub Project",
}
export interface ICreateEventAssociation {
  /** Entity Id */
  entityId: string;
  /** Entity type */
  entityType: EventAssociationEntityType;
}

export enum EventAccess {
  PRIVATE = "PRIVATE",
  ORG = "ORG",
  PUBLIC = "PUBLIC",
}

type SecondParameter<T extends (...args: any) => any> = Parameters<T>[1];

export const createEvent = (
  iCreateEvent: ICreateEvent,
  options?: SecondParameter<typeof customClient>
) => {
  return customClient<IEvent>(
    {
      url: `/api/events/v1/events`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: iCreateEvent,
    },
    options
  );
};

export const getEvents = (
  params?: GetEventsParams,
  options?: SecondParameter<typeof customClient>
) => {
  return customClient<IPagedEventResponse>(
    { url: `/api/events/v1/events`, method: "GET", params },
    options
  );
};

export const getEvent = (
  id: string,
  options?: SecondParameter<typeof customClient>
) => {
  return customClient<IEvent>(
    { url: `/api/events/v1/events/${id}`, method: "GET" },
    options
  );
};

export const updateEvent = (
  id: string,
  iUpdateEvent: IUpdateEvent,
  options?: SecondParameter<typeof customClient>
) => {
  return customClient<IEvent>(
    {
      url: `/api/events/v1/events/${id}`,
      method: "PATCH",
      headers: { "Content-Type": "application/json" },
      data: iUpdateEvent,
    },
    options
  );
};

export const deleteEvent = (
  id: string,
  options?: SecondParameter<typeof customClient>
) => {
  return customClient<IEvent>(
    { url: `/api/events/v1/events/${id}`, method: "DELETE" },
    options
  );
};

export const createRegistration = (
  iCreateRegistration: ICreateRegistration,
  options?: SecondParameter<typeof customClient>
) => {
  return customClient<IRegistration>(
    {
      url: `/api/events/v1/registrations`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: iCreateRegistration,
    },
    options
  );
};

export const getRegistrations = (
  params?: GetRegistrationsParams,
  options?: SecondParameter<typeof customClient>
) => {
  return customClient<IPagedRegistrationResponse>(
    { url: `/api/events/v1/registrations`, method: "GET", params },
    options
  );
};

export const getRegistration = (
  id: string,
  options?: SecondParameter<typeof customClient>
) => {
  return customClient<IRegistration>(
    { url: `/api/events/v1/registrations/${id}`, method: "GET" },
    options
  );
};

export const updateRegistration = (
  id: string,
  iUpdateRegistration: IUpdateRegistration,
  options?: SecondParameter<typeof customClient>
) => {
  return customClient<IRegistration>(
    {
      url: `/api/events/v1/registrations/${id}`,
      method: "PATCH",
      headers: { "Content-Type": "application/json" },
      data: iUpdateRegistration,
    },
    options
  );
};

export const deleteRegistration = (
  id: string,
  options?: SecondParameter<typeof customClient>
) => {
  return customClient<IRegistration>(
    { url: `/api/events/v1/registrations/${id}`, method: "DELETE" },
    options
  );
};

export type CreateEventResult = NonNullable<
  Awaited<ReturnType<typeof createEvent>>
>;
export type GetEventsResult = NonNullable<
  Awaited<ReturnType<typeof getEvents>>
>;
export type GetEventResult = NonNullable<Awaited<ReturnType<typeof getEvent>>>;
export type UpdateEventResult = NonNullable<
  Awaited<ReturnType<typeof updateEvent>>
>;
export type DeleteEventResult = NonNullable<
  Awaited<ReturnType<typeof deleteEvent>>
>;
export type CreateRegistrationResult = NonNullable<
  Awaited<ReturnType<typeof createRegistration>>
>;
export type GetRegistrationsResult = NonNullable<
  Awaited<ReturnType<typeof getRegistrations>>
>;
export type GetRegistrationResult = NonNullable<
  Awaited<ReturnType<typeof getRegistration>>
>;
export type UpdateRegistrationResult = NonNullable<
  Awaited<ReturnType<typeof updateRegistration>>
>;
export type DeleteRegistrationResult = NonNullable<
  Awaited<ReturnType<typeof deleteRegistration>>
>;
